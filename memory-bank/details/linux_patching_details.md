# Linuxでのパッチ適用詳細

このドキュメントでは、Windows環境でDLLインジェクションとメモリフックによって実現されているゲームの改変を、Linux環境へ移植する際の技術的な詳細について記述します。

## 1. 提供されたコードの分析 (Windows)

提供されたコードは、Windows (Win32/Win64) において、実行中のプロセス（`eu4.exe`）のメモリに直接パッチを当て、ゲームの動作を改変する「DLLインジェクション」または「メモリフック」と呼ばれる手法を用いています。

### `hooking.hpp` (インジェクタ本体)

-   **`scoped_basic` クラス**:
    -   RAII (Resource Acquisition Is Initialization) パターンを実装しています。
    -   `save()` メソッドで、指定されたメモリアドレス（`addr`）から、書き換える前の元の機械語コードをバッファ（`buf`）にバックアップします。
    -   デストラクタ（スコープを抜ける時）で `restore()` メソッドが呼ばれ、バックアップした元のコードを書き戻し、メモリ状態を元に戻します。
-   **`scoped_jmp` / `scoped_call` クラス**:
    -   `scoped_basic` を継承し、特定のメモリアドレス（`at`）に `JMP` 命令や `CALL` 命令（x86/x64では通常5バイト）を書き込むことに特化しています。
    -   これにより、`eu4.exe` の元の処理が実行される直前に、強制的に別の関数（`dest`、つまりDLL側で定義したフック関数）に処理をジャンプさせます。
-   **`function_hooker_manager` / `function_hooker_base`**:
    -   同じアドレスに対して複数のフックがかけられた場合に、それらをチェーン（連鎖）させて管理するための、より高度なラッパーです。
-   **`VirtualProtect` (推測)**:
    -   これらのクラスが内部で呼び出す `WriteMemoryRaw` や `MakeJMP` は、最終的にWindows APIの **`VirtualProtect`** を呼び出しています。
    -   実行可能コードが格納されている `.text` セクションは、通常「読み取り・実行のみ (`R-X`)」の権限しか持っていません。ここに `JMP` 命令を書き込むために、`VirtualProtect` を使って一時的にページの権限を「読み取り・書き込み・実行 (`RWX`)」に変更し、書き込み後に元に戻しています。

### `byte_pattern.cpp` (パターン検索)

-   フックを仕掛けるアドレス（`MakeJMP` の `at`）は、EXEのバージョンアップで変わりやすいため、ハードコードできません。
-   そこで、`find_pattern` を使い、特徴的な機械語の並び（バイトパターン）をメモリ上から検索し、フック対象のアドレスを動的に特定しています。
-   `get_module_ranges` は、Win32のPEヘッダを解析し、`eu4.exe` の `.text` や `.rdata` セクションのアドレス範囲を取得して、検索対象を絞り込んでいます。

### `dll_main.cpp` (実行フロー)

-   これはDLLがプロセス（`eu4.exe`）にロードされた際の起点（エントリポイント）です。
-   `DLL_PROCESS_ATTACH` のタイミングで、`BytePattern::StartLog` でログを開始し、`Version::GetVersionFromExe` でEXEのバージョンをチェックします。
-   各モジュールが、内部で `byte_pattern` による検索と `injector` によるフックを順番に実行し、ゲームの各機能にパッチを当てていきます。

## 2. Linux上での実現可能性と移植方針

Windows版が行っている「`VirtualProtect` による実行時メモリ書き換え」の、Linuxにおける正当な代替手段は **`mprotect(2)`** です。非PIEのELFバイナリ（`eu4`）に対してこの手法を移植することは可能です。

### Linux (ELF) 版パッチの処理フロー

1.  **対象プロセスのメモリマップ取得**:
    -   `eu4` がPIE形式ではないため、`dlopen` でロードすることはできません。
    -   パッチを当てる側（.soファイル、恐らく `LD_PRELOAD` などでロードさせる）は、実行時に `eu4` プロセスのメモリレイアウトを知る必要があります。
    -   `/proc/self/maps` ファイルを読み込むか、`dl_iterate_phdr(3)` 関数を利用して、`eu4` 本体（ファイルパスが `eu4` になっているエントリ）のベースアドレスと、実行可能セクション（`.text`）のアドレス範囲を特定します。

2.  **パターン検索**:
    -   `byte_pattern.cpp` の核となる `bm_search` ロジックはそのまま流用できます。
    -   `get_module_ranges` は、PEヘッダ解析から、上記1で取得したELFの `.text` セクションのアドレス範囲を使うように書き換える必要があります。
    -   この改造版 `byte_pattern` を使い、目的の機械語パターンを検索し、フック対象のアドレスを特定します。

3.  **メモリ保護の変更**:
    -   `mprotect(2)` はページ単位（通常4KB）で動作します。まず、フック対象アドレスが含まれるページの先頭アドレスを計算します。
    -   `mprotect` を呼び出し、該当ページに書き込み権限を付与します。
    -   **注意**: 最近のLinuxカーネルやセキュリティ設定では、W^X（Write XOR Execute）の原則により、**書き込み (`W`) と実行 (`X`) の権限を同時に付与することを禁止している**場合があります。

4.  **パッチの書き込みと権限の復元 (W^X対応)**:
    -   `mprotect` を2回使うのが最も安全で確実な方法です。
    -   **(a) 書き込み権限付与**: `mprotect(page_addr, 4096, PROT_READ | PROT_WRITE)` を呼び出し、一時的にページを書き込み可能（実行不可）にします。
    -   **(b) パッチ書き込み**: `scoped_jmp` に相当する処理、すなわちフック対象アドレスにJMP命令を書き込みます。この際、元のバイト列をバックアップしておきます。
    -   **(c) 実行権限復元**: `mprotect(page_addr, 4096, PROT_READ | PROT_EXEC)` を呼び出し、ページを元の実行可能（書き込み不可）な状態に戻します。

5.  **D言語での実装**:
    -   D言語から `mprotect` などのC言語関数を呼び出すことは容易です。`core.sys.posix.sys.mman` モジュールに `mprotect` が既に定義されているか、あるいはCの関数として宣言すれば、直接呼び出すことができます。

## 結論

`mmap`/`mprotect` の利用は、Windows版が行っている「`VirtualProtect` による実行時メモリ書き換え」の、Linuxにおける正当な代替手段です。`eu4` が非PIEであるという制約も `byte_pattern` と同様のスキャン手法で回避できるため、`get_module_ranges` 部分を `/proc/self/maps` または `dl_iterate_phdr` を使うロジックに置き換え、`VirtualProtect` の呼び出しを `mprotect`（W^Xを考慮した2回呼び出し）に置き換えることで、Linux上でも同様のパッチ（フック）が実現可能です。
